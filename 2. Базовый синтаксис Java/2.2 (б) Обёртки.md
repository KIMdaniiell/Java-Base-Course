# Обёртки

[(Доп.материал)](https://habr.com/ru/articles/104231/)

Классы обёртки содержат поле _value_ соответствующего примитивного типа.

## Работа с примитивами:

#### Boxing (упаковка):
Статический метод: `Integer.valueOf(1)`

#### Unboxing (распаковка):
Метод: `reference.intValue()`

**Пример:**
``` java
  int primitive = 0;
  Integer reference = Integer.valueOf(primitive);
  int backToPrimitive = reference.intValue();
```

#### Autoboxing:
Можно использовать объекты обертки там, где ожидается примитивный тип, и наоборот. Компилятор сам добавит упаковку и распаковку. Автобоксинг замедляет программу.
```java
  Integer a = 10;
  Integer b = 10;
  Integer c = a + b; // Распаковка обеих переменных -> вычисление суммы -> упаковка значения ;
```

## Работа со строками:

Статический метод:  `Integer.parseInt("12345")`

Статический метод:  `Integer.toString(12345)` - Может происходить автоматически - при контатенации со строкой

---

## Назначение классов обёрток:
+ использование в коллекциях ;
+ использование в случе, если помимо значения нужно значение _null_ ;
+ использование там, где нужны объекты ;

## Приколы:
+ При присваивании значения переменной типа Integer обычно выделяется память в куче под новый объект. Однако иногда переиспользуются старые объекты (это история про кэширование значений). [Иллюстрация](https://habr.com/ru/articles/104231/)
+ Любый операции над оберткой создают новый объект, а старый живет пока не произойдет сборка мусора. [Иллюстрация](https://habr.com/ru/articles/104231/)
+ Правило писать int везде, где можно не писать Integer, работает не всегда. [Иллюстрация](https://habr.com/ru/articles/104231/)
---

## Вопросы:
+ Зачем в Java, объектно-ориентированном языке, есть примитивные типы, не являющиеся объектами? Ведь есть полноценные объекты-аналоги java.lang.Integer и т.п.

  ```Примитивные типы нужны для производительности вычислений. Работа с объектами намного медленнее.```

+ Укажите преобразования типов, которые компилятор делает автоматически. Другими словами, для каких преобразований не требуется явно писать в программе оператор приведения типа?
  - [ ] float -> long
  - [ ] int -> boolean
  - [x] long -> float
  - [x] char -> Character
  - [ ] byte -> char (на этом я путался)
  - [x] char -> int
  - [x] int -> long
  - [ ] String -> int
  
