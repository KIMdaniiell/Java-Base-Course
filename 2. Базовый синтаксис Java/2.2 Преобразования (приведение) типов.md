# Преобразование типов

### Неявные преобразования (без потерь)
Компилятор способен производить неявные приведения. 
Такие преобразования отличаются приведением **менее ёмкого типа к более ёмкому**:
  + <details>
    <summary>Пример c целочисленными:</summary>
    
    ```java
    byte byteValue = 123;
    short shortValue = byteValue;
    int intValue = shortValue;
    long longValue = intValue;
    ```
    </details>
  + <details>
    <summary>Пример c символьными:</summary>
    
    ```java
    char charValue = `@`;
    int intValue = charValue;
    long longValue = intValue;
    ```
    </details>
  + <details>
    <summary>Пример c вещественными:</summary>

    ```java
    float floatValue = longValue;
    double doubleFromFloat = floatFromLong;
    double doubleFromInt = intValue;
    ```
  </details>
  
### Преобразования с потерями
Такие преобразования отличаются тем, что целевой тип **не может отразить все возможные значения** исходного типа:    

### Автоматическое расширение
При использовании бинарного оператора (математические, побитовые ...) оба операнда автоматически (неявно) приводятся к одному типу. Приоритет типа, выбираемого как целевой:
1. **_double_** (если хотя бы один из операндов является _double_);
2. **_float_** (если хотя бы один из операндов является _float_);
3. Во всех остальных случаях **_int_**. Пример:
   ```java
   byte a = 1;
   byte b = 1;
   byte c = (byte) (a + b);
   ```
   Причём `byte c = a + b;` - **не прокатит!**

Унарные операторы как `+=` тоже включают автоматическое расширение:
```java
  byte a = 1;
  a += 1;  // То же самое, что и
           // a = (byte) (a + 3);
```
```java
  byte a = -1; // 1111_1111
  a >>>= 7;    // a = (byte) (-1 >>> 7);
  // Ожидание:    1
  // Реальность: -1
```
**Рекомендация:**
1. Использовать типы **_byte_** и **_short_** только при необходимости (если это дает реальную экономию памяти - например при использовании массивов) ;
2. Использовать **_char_** только для хранения символов ;

